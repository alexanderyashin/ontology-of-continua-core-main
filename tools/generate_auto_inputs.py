#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Generate LaTeX \input lines for the Core main article from master_core_structure.yaml.

Compatible with the current Ontology of Continua Core YAML layout:

core:
  main_article:
    entrypoint: main.tex
    sections:
      - id: intro
        path: content/01_intro.tex
      ...

If in the future you want to support other shapes (simple list, root/sections/nodes),
the helper functions below already cover them.

Usage (defaults are fine for build_core.sh):
    python tools/generate_auto_inputs.py
    python tools/generate_auto_inputs.py --yaml master_core_structure.yaml --output content/_auto_core_inputs.tex
"""

import argparse
import sys
from pathlib import Path

try:
    import yaml
except ImportError:
    print("[ERROR] PyYAML is required: pip install pyyaml", file=sys.stderr)
    sys.exit(1)


# --------------------------------------------------------------------
# YAML loaders / extractors
# --------------------------------------------------------------------

def _extract_from_simple_list(data):
    """
    Case 1: top-level YAML is just a list of paths or dicts with 'path'.
    Example:
      - content/01_intro.tex
      - path: content/02_background.tex
    """
    paths = []
    for item in data:
        if isinstance(item, str):
            paths.append(item)
        elif isinstance(item, dict) and "path" in item:
            paths.append(item["path"])
    return paths


def _extract_from_root_tree(data):
    """
    Case 2: generic tree with root/sections/nodes.
    This is kept for backwards compatibility with an earlier design.

    Expected shape (conceptually):
      root:
        sections:
          - path: content/foo.tex
          - nodes:
              - path: content/bar.tex
    """

    def walk_node(node, acc):
        # node may contain direct path
        if isinstance(node, dict):
            if "path" in node and isinstance(node["path"], str):
                acc.append(node["path"])
            # nested sections or nodes
            for key in ("sections", "nodes", "children"):
                if key in node and isinstance(node[key], list):
                    for child in node[key]:
                        walk_node(child, acc)

    paths = []
    root = data.get("root", {})
    if isinstance(root, dict):
        sections = root.get("sections", [])
        if isinstance(sections, list):
            for node in sections:
                walk_node(node, paths)
    return paths


def _extract_from_core_main_article(data):
    """
    Case 3 (CURRENT PROJECT): structure with 'core' / 'main_article' / 'sections'.

    Expected shape:
    core:
      main_article:
        entrypoint: main.tex
        sections:
          - id: intro
            path: content/01_intro.tex
          - id: background
            path: content/02_background.tex
          ...
    """
    core = data.get("core", {})
    if not isinstance(core, dict):
        return []

    main_article = core.get("main_article", {})
    if not isinstance(main_article, dict):
        return []

    sections = main_article.get("sections", [])
    if not isinstance(sections, list):
        return []

    paths = []
    for sec in sections:
        if isinstance(sec, dict) and "path" in sec:
            paths.append(sec["path"])
    return paths


def extract_tex_paths(yaml_data):
    """
    Unified extractor:
    1) simple list
    2) old tree with root/sections/nodes
    3) current 'core.main_article.sections' scheme
    """
    # Case 1: plain list
    if isinstance(yaml_data, list):
        return _extract_from_simple_list(yaml_data)

    if not isinstance(yaml_data, dict):
        raise ValueError("Ожидал либо список, либо словарь с описанием структуры Core.")

    # Case 3: current Core schema (preferred for this project)
    paths = _extract_from_core_main_article(yaml_data)
    if paths:
        return paths

    # Case 2: generic tree with root/sections/nodes
    if "root" in yaml_data:
        paths = _extract_from_root_tree(yaml_data)
        if paths:
            return paths

    # If nothing matched, complain clearly
    raise ValueError(
        "Не могу понять структуру YAML для auto-inputs.\n"
        "Ожидал один из вариантов:\n"
        "  1) простой список путей;\n"
        "  2) дерево с ключами root/sections/nodes;\n"
        "  3) структуру core/main_article/sections (текущий формат)."
    )


# --------------------------------------------------------------------
# Writer
# --------------------------------------------------------------------

def write_inputs_file(output_path: Path, paths):
    """
    Write \input lines into the given file.
    If list is empty, still write a comment header so LaTeX doesn't break.
    """
    header = [
        "% ==========================================",
        "%  Auto-generated by generate_auto_inputs.py",
        "%  DO NOT EDIT THIS FILE MANUALLY",
        "% ==========================================",
        "",
    ]

    lines = header[:]

    if not paths:
        lines.append("% No auto-included sections defined in YAML.\n")
    else:
        for p in paths:
            # Normalize to forward slashes for LaTeX
            s = str(p).replace("\\", "/")
            lines.append(f"\\input{{{s}}}")

        # Ensure final newline
        lines.append("")

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(lines), encoding="utf-8")


# --------------------------------------------------------------------
# CLI
# --------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(
        description="Generate LaTeX \\input list from master_core_structure.yaml"
    )
    parser.add_argument(
        "--yaml",
        default="master_core_structure.yaml",
        help="YAML file describing Core structure",
    )
    parser.add_argument(
        "--output",
        default="content/_auto_core_inputs.tex",
        help="Path to the generated .tex with \\input lines",
    )

    args = parser.parse_args()

    yaml_path = Path(args.yaml)
    out_path = Path(args.output)

    if not yaml_path.exists():
        print(f"[ERROR] YAML file not found: {yaml_path}", file=sys.stderr)
        sys.exit(1)

    try:
        data = yaml.safe_load(yaml_path.read_text(encoding="utf-8"))
    except Exception as e:
        print(f"[ERROR] Failed to parse YAML: {e}", file=sys.stderr)
        sys.exit(1)

    try:
        paths = extract_tex_paths(data)
    except Exception as e:
        print(f"[inputs] ERROR: {e}", file=sys.stderr)
        # Still write a minimal file to keep LaTeX happy
        write_inputs_file(out_path, [])
        sys.exit(1)

    print(f"[inputs] Using YAML: {yaml_path}")
    print(f"[inputs] Found {len(paths)} section(s) for auto-include.")
    write_inputs_file(out_path, paths)
    print(f"[inputs] Written {len(paths)} \\input lines to {out_path}")


if __name__ == "__main__":
    main()
