#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Generate LaTeX \\input lines for the Core main article from master_core_structure.yaml.

NEUE VERSION (clean, minimal):
 - Keine modules.*.master mehr.
 - Unterstützt:
      * core.main_article.sections
      * top-level sections
      * root/sections (legacy)
 - Schreibt eindeutige Pfade nach content/_auto_core_inputs.tex
"""

import sys
from pathlib import Path
import yaml


# =====================================================================
# Extractors
# =====================================================================

def extract_from_core_main_article(data):
    core = data.get("core")
    if not isinstance(core, dict):
        return []

    main_article = core.get("main_article")
    if not isinstance(main_article, dict):
        return []

    sections = main_article.get("sections", [])
    paths = []

    if isinstance(sections, list):
        for sec in sections:
            if isinstance(sec, dict) and "path" in sec:
                paths.append(sec["path"])

    return paths


def extract_from_top_sections(data):
    sections = data.get("sections")
    paths = []

    if isinstance(sections, list):
        for sec in sections:
            if isinstance(sec, dict) and "path" in sec:
                paths.append(sec["path"])

    return paths


def extract_from_root_tree(data):
    def walk(node, acc):
        if isinstance(node, dict):
            if "path" in node and isinstance(node["path"], str):
                acc.append(node["path"])
            for key in ("sections", "nodes", "children"):
                if key in node and isinstance(node[key], list):
                    for c in node[key]:
                        walk(c, acc)

    paths = []
    root = data.get("root")
    if isinstance(root, dict):
        nodes = root.get("sections", [])
        if isinstance(nodes, list):
            for n in nodes:
                walk(n, paths)

    return paths


# =====================================================================
# Main extractor
# =====================================================================

def extract_paths(data):
    paths = []

    # 1) core.main_article.sections
    paths.extend(extract_from_core_main_article(data))

    # 2) top-level sections
    paths.extend(extract_from_top_sections(data))

    # 3) root/sections (legacy)
    paths.extend(extract_from_root_tree(data))

    # Deduplicate while preserving order
    result = []
    seen = set()

    for p in paths:
        p = str(p)
        if p not in seen:
            seen.add(p)
            result.append(p)

    if not result:
        raise ValueError(
            "Keine Pfade gefunden. Prüfe core.main_article.sections oder sections im YAML."
        )

    return result


# =====================================================================
# Writer
# =====================================================================

def write_inputs(tex_path: Path, paths):
    header = [
        "% ==========================================",
        "%  Auto-generated by generate_auto_inputs.py",
        "%  DO NOT EDIT THIS FILE MANUALLY",
        "% ==========================================",
        "",
    ]

    lines = header[:]

    for p in paths:
        lines.append(f"\\input{{{p}}}")

    lines.append("")

    tex_path.parent.mkdir(parents=True, exist_ok=True)
    tex_path.write_text("\n".join(lines), encoding="utf-8")


# =====================================================================
# CLI entry
# =====================================================================

def main():
    yaml_path = Path("master_core_structure.yaml")
    out_path = Path("content/_auto_core_inputs.tex")

    if not yaml_path.exists():
        print(f"[ERROR] YAML file missing: {yaml_path}", file=sys.stderr)
        sys.exit(1)

    try:
        data = yaml.safe_load(yaml_path.read_text(encoding="utf-8"))
    except Exception as e:
        print(f"[ERROR] YAML parse failed: {e}", file=sys.stderr)
        sys.exit(1)

    try:
        paths = extract_paths(data)
    except Exception as e:
        print(f"[ERROR] {e}", file=sys.stderr)
        write_inputs(out_path, [])
        sys.exit(1)

    print(f"[inputs] {len(paths)} paths collected.")
    write_inputs(out_path, paths)
    print(f"[inputs] Written to {out_path}")


if __name__ == "__main__":
    main()
